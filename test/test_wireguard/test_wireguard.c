#include <unity.h>

#include "wireguard/debug.h"
#include "wireguard/packet.h"
#include "wireguard/wireguard.h"

// Private keys generated by `wg genkey`
// Public keys generated by piping private key to `wg pubkey`
const char *peer1_private = "qCSYSlzXmzDcEOtU0OTc0IKwewLsVziNgo17W/KwF0g=";
const char *peer1_public = "iVKvGi0ZNENSBlKzJ7SzgTraoPepFZsh5aKm++l0dQc=";
const char *peer2_private = "YBUwZEwCi061mKK9J0Eh12wb62IXD+VtOeMz32aB8kg=";
const char *peer2_public = "uYe/Tilj7UxsgQjTww3ikTuzhIdDep5YdmtDczJlQRg=";

// Example IPv4 addresses
const struct wg_sockaddr peer1_addr = {
    .family = WG_AF_INET,
    .port_be16 = 0,
    .addr.v4.u8_be = {192, 168, 1, 1},
};
const struct wg_sockaddr peer2_addr = {
    .family = WG_AF_INET,
    .port_be16 = 0,
    .addr.v4.u8_be = {192, 168, 1, 2},
};

// Arbitrary MTU for our tests. Picked the minimum MTU on the public internet.
const int mtu = 576;

char packet_buffer[2048];

void send_receive_packet(struct wg_peer *sender, struct wg_peer *receiver, size_t data_len, int mtu)
{
	const size_t fixed_overhead = 16 + 16;		 // WireGuard header, Auth tag
	size_t padded_len = data_len + (-data_len & 15); // Next multiple of 16
	TEST_ASSERT_LESS_OR_EQUAL(mtu, data_len + fixed_overhead);
	if (padded_len + fixed_overhead > mtu) { // Padding & header size
		padded_len = mtu - fixed_overhead;
	}

	// Create a packet with some arbitrary test data
	struct wg_packet pkt;
	wg_packet_init(&pkt, packet_buffer, sizeof(packet_buffer));
	wg_packet_reserve(&pkt, 64);
	wg_packet_put(&pkt, data_len);
	for (int i = 0; i < data_len; i++) {
		pkt.data[i] = i & 0xFF;
	}

	// Encrypt
	TEST_ASSERT_EQUAL(0, wg_peer_generate_message_data(sender, &pkt));

	TEST_ASSERT_EQUAL(padded_len + fixed_overhead, wg_packet_data_len(&pkt));

	// Decrypt
	TEST_ASSERT_EQUAL(0, wg_peer_handle_message_data(receiver, &pkt));

	// Recovered plaintext length (includes padding!)
	TEST_ASSERT_EQUAL(padded_len, wg_packet_data_len(&pkt));

	// Actual plaintext
	for (int i = 0; i < data_len; i++) {
		TEST_ASSERT_EQUAL(i & 0xFF, pkt.data[i]);
	}

	// Padding part of plaintext
	for (int i = data_len; i < wg_packet_data_len(&pkt); i++) {
		TEST_ASSERT_EQUAL(0, pkt.data[i]);
	}
}

void test_tunnel(void)
{
	struct wg_peer peer1;
	struct wg_peer peer2;
	union wg_key empty_key = {};
	union wg_symmetric_key empty_symmetric_key = {};
	union wg_hash empty_hash = {};
	bool cookie_required = false;

	union wg_message_handshake_initiation handshake_initiation_msg;
	union wg_message_handshake_response handshake_response_msg;

	// Initialize initiator
	TEST_ASSERT_EQUAL(0, wg_peer_init(&peer1));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_private_key_base64(&peer1, peer1_private, strlen(peer1_private)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_public_key_base64(&peer1, peer1_public, strlen(peer1_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_remote_public_key_base64(&peer1, peer2_public, strlen(peer2_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer1, mtu));

	// Initialize responder
	TEST_ASSERT_EQUAL(0, wg_peer_init(&peer2));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_private_key_base64(&peer2, peer2_private, strlen(peer2_private)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_public_key_base64(&peer2, peer2_public, strlen(peer2_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_remote_public_key_base64(&peer2, peer1_public, strlen(peer1_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer2, mtu));

	// Send and receive handshake initiation message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_initiation(&peer1, &handshake_initiation_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_initiation(&peer2, &handshake_initiation_msg, &peer1_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);
	TEST_ASSERT_EQUAL(true, peer1.session.is_initiator);
	TEST_ASSERT_FALSE(wg_key_equals(&peer1.session.local_ephemeral_public, &empty_key));
	TEST_ASSERT_TRUE(wg_key_equals(&peer1.session.remote_ephemeral_public, &empty_key));
	TEST_ASSERT_FALSE(wg_key_equals(&peer1.session.chaining_key, &empty_key));
	TEST_ASSERT_TRUE(wg_hash_equals(&peer1.session.remote_hash, &empty_hash));
	TEST_ASSERT_FALSE(wg_hash_equals(&peer1.session.local_hash, &empty_hash));
	TEST_ASSERT_TRUE(wg_symmetric_key_equals(&peer1.session.sending_key, &empty_symmetric_key));
	TEST_ASSERT_TRUE(wg_symmetric_key_equals(&peer1.session.receiving_key, &empty_symmetric_key));
	TEST_ASSERT_EQUAL(false, peer2.session.is_initiator);
	TEST_ASSERT_TRUE(wg_key_equals(&peer2.session.local_ephemeral_public, &empty_key));
	TEST_ASSERT_FALSE(wg_key_equals(&peer2.session.remote_ephemeral_public, &empty_key));
	TEST_ASSERT_FALSE(wg_key_equals(&peer2.session.chaining_key, &empty_key));
	TEST_ASSERT_FALSE(wg_hash_equals(&peer2.session.remote_hash, &empty_hash));
	TEST_ASSERT_TRUE(wg_hash_equals(&peer2.session.local_hash, &empty_hash));
	TEST_ASSERT_TRUE(wg_symmetric_key_equals(&peer2.session.sending_key, &empty_symmetric_key));
	TEST_ASSERT_TRUE(wg_symmetric_key_equals(&peer2.session.receiving_key, &empty_symmetric_key));
	TEST_ASSERT(wg_key_equals(&peer1.session.local_ephemeral_public, &peer2.session.remote_ephemeral_public));
	TEST_ASSERT(wg_key_equals(&peer1.session.remote_ephemeral_public, &peer2.session.local_ephemeral_public));
	TEST_ASSERT(wg_key_equals(&peer1.session.chaining_key, &peer2.session.chaining_key));
	TEST_ASSERT(wg_hash_equals(&peer1.session.remote_hash, &peer2.session.local_hash));
	TEST_ASSERT(wg_hash_equals(&peer1.session.local_hash, &peer2.session.remote_hash));

	// Send and receive handshake initiation reply message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_response(&peer2, &handshake_response_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_response(&peer1, &handshake_response_msg, &peer2_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);
	TEST_ASSERT_EQUAL(true, peer1.session.is_initiator);
	TEST_ASSERT_TRUE(wg_key_equals(&peer1.session.local_ephemeral_public, &empty_key));
	TEST_ASSERT_TRUE(wg_key_equals(&peer1.session.remote_ephemeral_public, &empty_key));
	TEST_ASSERT_TRUE(wg_key_equals(&peer1.session.chaining_key, &empty_key));
	TEST_ASSERT_TRUE(wg_hash_equals(&peer1.session.remote_hash, &empty_hash));
	TEST_ASSERT_TRUE(wg_hash_equals(&peer1.session.local_hash, &empty_hash));
	TEST_ASSERT_EQUAL(false, peer2.session.is_initiator);
	TEST_ASSERT_TRUE(wg_key_equals(&peer2.session.local_ephemeral_public, &empty_key));
	TEST_ASSERT_TRUE(wg_key_equals(&peer2.session.remote_ephemeral_public, &empty_key));
	TEST_ASSERT_TRUE(wg_key_equals(&peer2.session.chaining_key, &empty_key));
	TEST_ASSERT_TRUE(wg_hash_equals(&peer2.session.remote_hash, &empty_hash));
	TEST_ASSERT_TRUE(wg_hash_equals(&peer2.session.local_hash, &empty_hash));
	TEST_ASSERT(wg_symmetric_key_equals(&peer1.session.sending_key, &peer2.session.receiving_key));
	TEST_ASSERT(wg_symmetric_key_equals(&peer1.session.receiving_key, &peer2.session.sending_key));
	TEST_ASSERT_EQUAL(peer1.session.local_index, peer2.session.remote_index);
	TEST_ASSERT_EQUAL(peer2.session.local_index, peer1.session.remote_index);
	TEST_ASSERT_EQUAL(0, peer2.session.sending_key_counter);
	TEST_ASSERT_EQUAL(0, peer1.session.receiving_key_counter);

	// Test all possible packet lengths (MTU - WG header - Auth tag)
	for (size_t data_len = 0; data_len < mtu - 16 - 16; data_len++) {
		// Test both directions
		send_receive_packet(&peer1, &peer2, data_len, mtu);
		send_receive_packet(&peer2, &peer1, data_len, mtu);

		// Ensure we don't rely on a "send one receive one" pattern
		send_receive_packet(&peer1, &peer2, data_len, mtu);
	}

	// Destruction of initiator and resopnder
	TEST_ASSERT_EQUAL(0, wg_peer_fini(&peer1));
	TEST_ASSERT_EQUAL(0, wg_peer_fini(&peer2));
	TEST_ASSERT_EACH_EQUAL_UINT8(0, &peer1, sizeof(peer1));
	TEST_ASSERT_EACH_EQUAL_UINT8(0, &peer2, sizeof(peer2));
}

void test_handshake_both_cookies(void)
{
	struct wg_peer peer1;
	struct wg_peer peer2;
	union wg_key empty_key = {};
	union wg_symmetric_key empty_symmetric_key = {};
	union wg_hash empty_hash = {};
	bool cookie_required = false;

	union wg_message_handshake_initiation handshake_initiation_msg;
	union wg_message_handshake_response handshake_response_msg;
	union wg_message_cookie_reply cookie_reply_1;
	union wg_message_cookie_reply cookie_reply_2;

	// Initialize initiator
	TEST_ASSERT_EQUAL(0, wg_peer_init(&peer1));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_private_key_base64(&peer1, peer1_private, strlen(peer1_private)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_public_key_base64(&peer1, peer1_public, strlen(peer1_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_remote_public_key_base64(&peer1, peer2_public, strlen(peer2_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer1, mtu));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer1, mtu));
	TEST_ASSERT_EQUAL(0, wg_peer_set_busy(&peer1, true));

	// Initialize responder
	TEST_ASSERT_EQUAL(0, wg_peer_init(&peer2));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_private_key_base64(&peer2, peer2_private, strlen(peer2_private)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_public_key_base64(&peer2, peer2_public, strlen(peer2_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_remote_public_key_base64(&peer2, peer1_public, strlen(peer1_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer2, mtu));
	TEST_ASSERT_EQUAL(0, wg_peer_set_busy(&peer2, true));

	// Send and receive handshake initiation message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_initiation(&peer1, &handshake_initiation_msg));
	TEST_ASSERT_EQUAL(1, wg_peer_handle_handshake_initiation(&peer2, &handshake_initiation_msg, &peer1_addr, &cookie_required));
	TEST_ASSERT_EQUAL(true, cookie_required);

	// Send and receive cookie reply
	TEST_ASSERT_EQUAL(0, wg_generate_message_cookie_reply(&peer2, &cookie_reply_1, &peer1_addr, handshake_initiation_msg.as_fields.sender_index_le32, &handshake_initiation_msg.as_fields.mac1));
	TEST_ASSERT_EQUAL(0, wg_handle_message_cookie_reply(&peer1, &cookie_reply_1));

	// Retransmit and receive handshake initiation message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_initiation(&peer1, &handshake_initiation_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_initiation(&peer2, &handshake_initiation_msg, &peer1_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);

	// Send and receive handshake reply message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_response(&peer2, &handshake_response_msg));
	TEST_ASSERT_EQUAL(1, wg_peer_handle_handshake_response(&peer1, &handshake_response_msg, &peer2_addr, &cookie_required));
	TEST_ASSERT_EQUAL(true, cookie_required);

	// Send and receive cookie reply
	TEST_ASSERT_EQUAL(0, wg_generate_message_cookie_reply(&peer1, &cookie_reply_2, &peer2_addr, handshake_response_msg.as_fields.sender_index_le32, &handshake_response_msg.as_fields.mac1));
	TEST_ASSERT_EQUAL(0, wg_handle_message_cookie_reply(&peer2, &cookie_reply_2));

	// Eventually REKEY-TIMEOUT expires. Retransmit and receive handshake initiation message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_initiation(&peer1, &handshake_initiation_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_initiation(&peer2, &handshake_initiation_msg, &peer1_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);

	// Send and receive handshake reply
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_response(&peer2, &handshake_response_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_response(&peer1, &handshake_response_msg, &peer2_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);

	// Send some data
	send_receive_packet(&peer1, &peer2, 128, mtu);
	send_receive_packet(&peer2, &peer1, 128, mtu);

	// Destruction of initiator and resopnder
	TEST_ASSERT_EQUAL(0, wg_peer_fini(&peer1));
	TEST_ASSERT_EQUAL(0, wg_peer_fini(&peer2));
	TEST_ASSERT_EACH_EQUAL_UINT8(0, &peer1, sizeof(peer1));
	TEST_ASSERT_EACH_EQUAL_UINT8(0, &peer2, sizeof(peer2));
}

void test_handshake_cookie_by_responder_only(void)
{
	struct wg_peer peer1;
	struct wg_peer peer2;
	union wg_key empty_key = {};
	union wg_symmetric_key empty_symmetric_key = {};
	union wg_hash empty_hash = {};
	bool cookie_required = false;

	union wg_message_handshake_initiation handshake_initiation_msg;
	union wg_message_handshake_response handshake_response_msg;
	union wg_message_cookie_reply cookie_reply_1;
	union wg_message_cookie_reply cookie_reply_2;

	// Initialize initiator
	TEST_ASSERT_EQUAL(0, wg_peer_init(&peer1));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_private_key_base64(&peer1, peer1_private, strlen(peer1_private)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_public_key_base64(&peer1, peer1_public, strlen(peer1_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_remote_public_key_base64(&peer1, peer2_public, strlen(peer2_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer1, mtu));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer1, mtu));
	TEST_ASSERT_EQUAL(0, wg_peer_set_busy(&peer1, false));

	// Initialize responder
	TEST_ASSERT_EQUAL(0, wg_peer_init(&peer2));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_private_key_base64(&peer2, peer2_private, strlen(peer2_private)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_public_key_base64(&peer2, peer2_public, strlen(peer2_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_remote_public_key_base64(&peer2, peer1_public, strlen(peer1_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer2, mtu));
	TEST_ASSERT_EQUAL(0, wg_peer_set_busy(&peer2, true));

	// Send and receive handshake initiation message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_initiation(&peer1, &handshake_initiation_msg));
	TEST_ASSERT_EQUAL(1, wg_peer_handle_handshake_initiation(&peer2, &handshake_initiation_msg, &peer1_addr, &cookie_required));
	TEST_ASSERT_EQUAL(true, cookie_required);

	// Send and receive cookie reply
	TEST_ASSERT_EQUAL(0, wg_generate_message_cookie_reply(&peer2, &cookie_reply_1, &peer1_addr, handshake_initiation_msg.as_fields.sender_index_le32, &handshake_initiation_msg.as_fields.mac1));
	TEST_ASSERT_EQUAL(0, wg_handle_message_cookie_reply(&peer1, &cookie_reply_1));

	// Retransmit and receive handshake initiation message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_initiation(&peer1, &handshake_initiation_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_initiation(&peer2, &handshake_initiation_msg, &peer1_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);

	// Send and receive handshake reply message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_response(&peer2, &handshake_response_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_response(&peer1, &handshake_response_msg, &peer2_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);

	// Send some data
	send_receive_packet(&peer1, &peer2, 128, mtu);
	send_receive_packet(&peer2, &peer1, 128, mtu);

	// Destruction of initiator and resopnder
	TEST_ASSERT_EQUAL(0, wg_peer_fini(&peer1));
	TEST_ASSERT_EQUAL(0, wg_peer_fini(&peer2));
	TEST_ASSERT_EACH_EQUAL_UINT8(0, &peer1, sizeof(peer1));
	TEST_ASSERT_EACH_EQUAL_UINT8(0, &peer2, sizeof(peer2));
}

void test_handshake_cookie_by_initiator_only(void)
{
	struct wg_peer peer1;
	struct wg_peer peer2;
	union wg_key empty_key = {};
	union wg_symmetric_key empty_symmetric_key = {};
	union wg_hash empty_hash = {};
	bool cookie_required = false;

	union wg_message_handshake_initiation handshake_initiation_msg;
	union wg_message_handshake_response handshake_response_msg;
	union wg_message_cookie_reply cookie_reply_1;
	union wg_message_cookie_reply cookie_reply_2;

	// Initialize initiator
	TEST_ASSERT_EQUAL(0, wg_peer_init(&peer1));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_private_key_base64(&peer1, peer1_private, strlen(peer1_private)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_public_key_base64(&peer1, peer1_public, strlen(peer1_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_remote_public_key_base64(&peer1, peer2_public, strlen(peer2_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer1, mtu));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer1, mtu));
	TEST_ASSERT_EQUAL(0, wg_peer_set_busy(&peer1, true));

	// Initialize responder
	TEST_ASSERT_EQUAL(0, wg_peer_init(&peer2));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_private_key_base64(&peer2, peer2_private, strlen(peer2_private)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_local_public_key_base64(&peer2, peer2_public, strlen(peer2_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_remote_public_key_base64(&peer2, peer1_public, strlen(peer1_public)));
	TEST_ASSERT_EQUAL(0, wg_peer_set_mtu(&peer2, mtu));
	TEST_ASSERT_EQUAL(0, wg_peer_set_busy(&peer2, false));

	// Send and receive handshake initiation message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_initiation(&peer1, &handshake_initiation_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_initiation(&peer2, &handshake_initiation_msg, &peer1_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);

	// Send and receive handshake reply message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_response(&peer2, &handshake_response_msg));
	TEST_ASSERT_EQUAL(1, wg_peer_handle_handshake_response(&peer1, &handshake_response_msg, &peer2_addr, &cookie_required));
	TEST_ASSERT_EQUAL(true, cookie_required);

	// Send and receive cookie reply
	TEST_ASSERT_EQUAL(0, wg_generate_message_cookie_reply(&peer1, &cookie_reply_2, &peer2_addr, handshake_response_msg.as_fields.sender_index_le32, &handshake_response_msg.as_fields.mac1));
	TEST_ASSERT_EQUAL(0, wg_handle_message_cookie_reply(&peer2, &cookie_reply_2));

	// Eventually REKEY-TIMEOUT expires. Retransmit and receive handshake initiation message
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_initiation(&peer1, &handshake_initiation_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_initiation(&peer2, &handshake_initiation_msg, &peer1_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);

	// Send and receive handshake reply
	TEST_ASSERT_EQUAL(0, wg_peer_generate_handshake_response(&peer2, &handshake_response_msg));
	TEST_ASSERT_EQUAL(0, wg_peer_handle_handshake_response(&peer1, &handshake_response_msg, &peer2_addr, &cookie_required));
	TEST_ASSERT_EQUAL(false, cookie_required);

	// Send some data
	send_receive_packet(&peer1, &peer2, 128, mtu);
	send_receive_packet(&peer2, &peer1, 128, mtu);

	// Destruction of initiator and resopnder
	TEST_ASSERT_EQUAL(0, wg_peer_fini(&peer1));
	TEST_ASSERT_EQUAL(0, wg_peer_fini(&peer2));
	TEST_ASSERT_EACH_EQUAL_UINT8(0, &peer1, sizeof(peer1));
	TEST_ASSERT_EACH_EQUAL_UINT8(0, &peer2, sizeof(peer2));
}

void test_window_check(void)
{
	struct wg_window window = {
	    .bitmap = ~0U,
	    .last_seq = ~0ULL};

	// The reset state should be equal to a zero-initialized struct
	TEST_ASSERT_EQUAL(0, wg_window_init(&window));
	TEST_ASSERT_EACH_EQUAL_UINT8(0, &window, sizeof(window));

	// Normal counting is valid
	for (int i = 1; i <= 100; i++) {
		TEST_ASSERT_EQUAL(0, wg_window_check(&window, i));
	}

	// Re-using is not valid
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 101));
	TEST_ASSERT_EQUAL(1, wg_window_check(&window, 101));
	TEST_ASSERT_EQUAL(1, wg_window_check(&window, 101));
	TEST_ASSERT_EQUAL(1, wg_window_check(&window, 101));

	// Continuing after bad packets is valid
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 102));

	// Small jumps are valid
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 120));
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 140));
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 160));
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 180));
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 200));

	// Back-filling within the window is valid
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 190));
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 191));
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 193));
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 197));

	// Back-filling outside the window is invalid
	TEST_ASSERT_EQUAL(1, wg_window_check(&window, 130));

	// Large jumps are valid
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 10000));

	// Back-filling outside the window is not valid after large jumps as well
	TEST_ASSERT_EQUAL(1, wg_window_check(&window, 9000));

	// Re-using is still not valid
	TEST_ASSERT_EQUAL(1, wg_window_check(&window, 10000));

	// The absolute maximum possible sequence number (2^64-1) is valid
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, ~0ULL));

	// Wrapping is not valid
	TEST_ASSERT_EQUAL(1, wg_window_check(&window, 1));

	// Reset should allow old values
	TEST_ASSERT_EQUAL(0, wg_window_init(&window));
	TEST_ASSERT_EQUAL(0, wg_window_check(&window, 101));
}

int main(int argc, char **argv)
{
	if (0 != wg_init()) {
		return 1;
	}

	UNITY_BEGIN();
	RUN_TEST(test_tunnel);
	RUN_TEST(test_handshake_both_cookies);
	RUN_TEST(test_handshake_cookie_by_responder_only);
	RUN_TEST(test_handshake_cookie_by_initiator_only);
	RUN_TEST(test_window_check);
	UNITY_END();

	return 0;
}
